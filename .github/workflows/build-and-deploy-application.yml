name: Build and Deploy Application

on:
  push:
    branches: [main, master]
    paths:
      - "helixium-web/**"
      - "Dockerfile*"
      - "docker-compose.yml"
      - "nginx.conf"
      - ".dockerignore"
      - ".github/workflows/build-and-deploy-application.yml"
  workflow_run:
    workflows: ["Build and Deploy Terraform Infrastructure"]
    types:
      - completed
    branches: [main, master]
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Docker image tag to deploy (default: latest)"
        required: false
        default: "latest"

env:
  AWS_REGION: ${{ vars.AWS_REGION || 'ap-southeast-2' }}
  ECS_CLUSTER: "helixium-cluster"
  ECS_SERVICE: "helixium-service"
  ECS_TASK_DEFINITION: "helixium"

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    name: Build and Deploy Application
    environment: dev
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'push' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Debug Workflow Trigger
        run: |
          echo "üîç DEBUGGING WORKFLOW TRIGGER:"
          echo "Event name: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Branch: ${{ github.ref_name }}"
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "Triggered by workflow: ${{ github.event.workflow_run.name }}"
            echo "Workflow conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "Workflow run ID: ${{ github.event.workflow_run.id }}"
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION || 'ap-southeast-2' }}

      - name: Check if infrastructure is deployed
        run: |
          if aws ecs describe-clusters --clusters ${{ env.ECS_CLUSTER }} --query 'clusters[0].status' --output text 2>/dev/null | grep -q ACTIVE; then
            echo "ECS cluster is active"
          else
            echo "ECS cluster not found or not active"
            echo "Please run the infrastructure deployment workflow first"
            exit 1
          fi

      - name: Get ECR Repository URLs
        run: |
          echo "üîç Getting ECR repository URLs..."

          # Try to get ECR repository URLs from AWS directly
          echo "üìã Getting ECR repository URLs from AWS..."

          # Get production repository URL
          ECR_REPO_URL=$(aws ecr describe-repositories \
            --repository-names helixium-web \
            --query 'repositories[0].repositoryUri' \
            --output text 2>/dev/null || echo "")

          # Get development repository URL  
          ECR_DEV_REPO_URL=$(aws ecr describe-repositories \
            --repository-names helixium-web-dev \
            --query 'repositories[0].repositoryUri' \
            --output text 2>/dev/null || echo "")

          if [ -n "$ECR_REPO_URL" ] && [ -n "$ECR_DEV_REPO_URL" ]; then
            echo "ECR_REPOSITORY_URL=$ECR_REPO_URL" >> $GITHUB_ENV
            echo "ECR_DEV_REPOSITORY_URL=$ECR_DEV_REPO_URL" >> $GITHUB_ENV
            echo "‚úÖ ECR repository URLs retrieved from AWS"
            echo "  Production: $ECR_REPO_URL"
            echo "  Development: $ECR_DEV_REPO_URL"
          else
            echo "‚ùå Could not get ECR repository URLs from AWS"
            echo "üí° This might mean:"
            echo "   - Infrastructure hasn't been deployed yet"
            echo "   - ECR repositories don't exist"
            echo "   - AWS credentials don't have ECR permissions"
            echo ""
            echo "üîß Please run the infrastructure deployment workflow first"
            exit 1
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set image tag
        id: set-tag
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.image_tag }}" ]; then
            echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

      # Build and push production Docker image (for main/master)
      - name: Build and push production Docker image
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ env.ECR_REPOSITORY_URL }}:latest,${{ env.ECR_REPOSITORY_URL }}:${{ steps.set-tag.outputs.tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Build and push development Docker image (for main/master)
      - name: Build and push development Docker image
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.dev
          push: true
          tags: ${{ env.ECR_DEV_REPOSITORY_URL }}:${{ steps.set-tag.outputs.tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Build and push development Docker image (for pull requests)
      - name: Build and push development Docker image (PR)
        if: github.event_name == 'pull_request'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.dev
          push: true
          tags: ${{ env.ECR_DEV_REPOSITORY_URL }}:pr-${{ github.event.number }}-${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Check if task definition exists
        id: check-task-def
        run: |
          if aws ecs describe-task-definition --task-definition ${{ env.ECS_TASK_DEFINITION }} --query taskDefinition > task-definition.json 2>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Task definition found"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Task definition not found - infrastructure may not be deployed"
            echo "Please run the infrastructure deployment workflow first"
            exit 1
          fi

      - name: Update task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.json
          container-name: helixium-web
          image: ${{ env.ECR_REPOSITORY_URL }}:${{ steps.set-tag.outputs.tag }}

      - name: Deploy to Amazon ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: false

      - name: Get deployment URL
        run: |
          echo "üîç Getting deployment URL..."

          # Wait a moment for the deployment to start
          echo "‚è≥ Waiting for deployment to start..."
          sleep 30

          # Function to get public IP with retry logic
          get_public_ip() {
            local max_attempts=20  # Increased to 20 attempts over ~5 minutes
            local attempt=1
            local base_delay=15
            local max_delay=45
            
            echo "üîÑ Starting retry loop to get public IP (max $max_attempts attempts, ~5 minutes total)..."
            
            while [ $attempt -le $max_attempts ]; do
              echo "üìã Attempt $attempt/$max_attempts..."
              
              # Get the task ARN
              TASK_ARN=$(aws ecs list-tasks \
                --cluster ${{ env.ECS_CLUSTER }} \
                --service-name ${{ env.ECS_SERVICE }} \
                --query 'taskArns[0]' \
                --output text 2>/dev/null || echo "")

              if [ "$TASK_ARN" != "None" ] && [ -n "$TASK_ARN" ]; then
                echo "‚úÖ Task found: $TASK_ARN"
                
                # Get detailed task info for debugging
                echo "üîç Getting detailed task information..."
                aws ecs describe-tasks \
                  --cluster ${{ env.ECS_CLUSTER }} \
                  --tasks $TASK_ARN \
                  --query 'tasks[0].{lastStatus:lastStatus,desiredStatus:desiredStatus,healthStatus:healthStatus,attachments:attachments}' \
                  --output table
                
                # Check if task is running
                TASK_STATUS=$(aws ecs describe-tasks \
                  --cluster ${{ env.ECS_CLUSTER }} \
                  --tasks $TASK_ARN \
                  --query 'tasks[0].lastStatus' \
                  --output text 2>/dev/null || echo "")
                
                if [ "$TASK_STATUS" = "RUNNING" ]; then
                  echo "‚úÖ Task is RUNNING, checking for public IP..."
                  
                  # Get the public IP
                  PUBLIC_IP=$(aws ecs describe-tasks \
                    --cluster ${{ env.ECS_CLUSTER }} \
                    --tasks $TASK_ARN \
                    --query 'tasks[0].attachments[0].details[?name==`publicIp`].value' \
                    --output text 2>/dev/null || echo "")

                  if [ -n "$PUBLIC_IP" ] && [ "$PUBLIC_IP" != "None" ]; then
                    echo "üéâ Public IP found: $PUBLIC_IP"
                    echo "üåê Application deployed successfully!"
                    echo "üîó Access your application at: http://$PUBLIC_IP"
                    echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
                    return 0
                  else
                    echo "‚è≥ Public IP not available yet (attempt $attempt/$max_attempts)"
                    echo "üîç Task is running but public IP not yet assigned"
                  fi
                else
                  echo "‚è≥ Task status: $TASK_STATUS (waiting for RUNNING state)"
                fi
              else
                echo "‚è≥ No tasks found yet (attempt $attempt/$max_attempts)"
              fi
              
              # Calculate delay with jitter (exponential backoff with random component)
              if [ $attempt -lt $max_attempts ]; then
                # Exponential backoff: base_delay * 2^(attempt-1)
                local exp_delay=$((base_delay * (2 ** (attempt - 1))))
                # Cap at max_delay
                local delay=$((exp_delay < max_delay ? exp_delay : max_delay))
                # Add jitter: random value between 0 and delay/2
                local jitter=$((RANDOM % (delay / 2 + 1)))
                local total_delay=$((delay + jitter))
                
                echo "‚è≥ Waiting ${total_delay}s before next attempt (base: ${delay}s + jitter: ${jitter}s)..."
                sleep $total_delay
              fi
              
              attempt=$((attempt + 1))
            done
            
            echo "‚ö†Ô∏è  Could not retrieve public IP after $max_attempts attempts"
            echo "üí° This is normal - the task may still be starting up"
            echo "üîç Check the ECS console for task status and public IP"
            echo "üîó You can also check the ECS console directly:"
            echo "   https://console.aws.amazon.com/ecs/home?region=${{ vars.AWS_REGION || 'ap-southeast-2' }}#/clusters/${{ env.ECS_CLUSTER }}/services/${{ env.ECS_SERVICE }}/tasks"
            return 1
          }

          # Call the function
          get_public_ip

      - name: Application Deployment Summary
        run: |
          echo "üéâ Application build and deployment completed successfully!"
          echo ""
          echo "üê≥ Built and Pushed Images:"
          if [ "${{ github.ref }}" = "refs/heads/main" ] || [ "${{ github.ref }}" = "refs/heads/master" ]; then
            echo "  ‚Ä¢ Production: ${{ env.ECR_REPOSITORY_URL }}:latest"
            echo "  ‚Ä¢ Production: ${{ env.ECR_REPOSITORY_URL }}:${{ steps.set-tag.outputs.tag }}"
            echo "  ‚Ä¢ Development: ${{ env.ECR_DEV_REPOSITORY_URL }}:${{ steps.set-tag.outputs.tag }}"
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "  ‚Ä¢ Development: ${{ env.ECR_DEV_REPOSITORY_URL }}:pr-${{ github.event.number }}-${{ github.sha }}"
          fi
          echo ""
          echo "üöÄ Deployed to ECS:"
          echo "  ‚Ä¢ Cluster: ${{ env.ECS_CLUSTER }}"
          echo "  ‚Ä¢ Service: ${{ env.ECS_SERVICE }}"
          echo "  ‚Ä¢ Image: ${{ env.ECR_REPOSITORY_URL }}:${{ steps.set-tag.outputs.tag }}"
          echo ""
          if [ -n "${{ env.PUBLIC_IP }}" ]; then
            echo "üåê Application URL: http://${{ env.PUBLIC_IP }}"
          fi
          echo ""
          echo "üìù Next steps:"
          echo "  1. Test your application at the provided URL"
          echo "  2. Monitor logs in CloudWatch"
          echo "  3. Scale your service as needed"
