name: Build and Deploy Application

on:
  push:
    branches: [main, master]
    paths:
      - "helixium-web/**"
      - "Dockerfile*"
      - "docker-compose.yml"
      - "nginx.conf"
      - ".dockerignore"
      - ".github/workflows/build-and-deploy-application.yml"
  workflow_run:
    workflows: ["Build and Deploy Terraform Infrastructure"]
    types:
      - completed
    branches: [main, master]
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Docker image tag to deploy (default: latest)"
        required: false
        default: "latest"

env:
  AWS_REGION: ${{ vars.AWS_REGION || 'ap-southeast-2' }}
  ECS_CLUSTER: "helixium-cluster"
  ECS_SERVICE: "helixium-service"
  ECS_TASK_DEFINITION: "helixium"

jobs:
  setup:
    runs-on: ubuntu-latest
    name: Setup and Validation
    environment: dev
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'push' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    outputs:
      ecr-repo-url: ${{ steps.get-ecr-urls.outputs.ecr-repo-url }}
      image-tag: ${{ steps.set-tag.outputs.tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Debug Workflow Trigger
        run: |
          echo "🔍 DEBUGGING WORKFLOW TRIGGER:"
          echo "Event name: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Branch: ${{ github.ref_name }}"
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "Triggered by workflow: ${{ github.event.workflow_run.name }}"
            echo "Workflow conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "Workflow run ID: ${{ github.event.workflow_run.id }}"
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION || 'ap-southeast-2' }}

      - name: Check if infrastructure is deployed
        run: |
          if aws ecs describe-clusters --clusters ${{ env.ECS_CLUSTER }} --query 'clusters[0].status' --output text 2>/dev/null | grep -q ACTIVE; then
            echo "ECS cluster is active"
          else
            echo "ECS cluster not found or not active"
            echo "Please run the infrastructure deployment workflow first"
            exit 1
          fi

      - name: Get ECR Repository URLs
        id: get-ecr-urls
        run: |
          echo "🔍 Getting ECR repository URLs..."

          # Try to get ECR repository URLs from AWS directly
          echo "📋 Getting ECR repository URLs from AWS..."

          # Get production repository URL
          ECR_REPO_URL=$(aws ecr describe-repositories \
            --repository-names helixium-web \
            --query 'repositories[0].repositoryUri' \
            --output text 2>/dev/null || echo "")

          if [ -n "$ECR_REPO_URL" ]; then
            echo "ecr-repo-url=$ECR_REPO_URL" >> $GITHUB_OUTPUT
            echo "✅ ECR production repository URL retrieved from AWS"
            echo "  Production: $ECR_REPO_URL"
          else
            echo "❌ Could not get ECR production repository URL from AWS"
            echo "💡 This might mean:"
            echo "   - Infrastructure hasn't been deployed yet"
            echo "   - ECR production repository doesn't exist"
            echo "   - AWS credentials don't have ECR permissions"
            echo ""
            echo "🔧 Please run the infrastructure deployment workflow first"
            exit 1
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set image tag
        id: set-tag
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.image_tag }}" ]; then
            echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

  build-images:
    runs-on: ubuntu-latest
    name: 🐳 Build Docker Images
    needs: setup
    environment: dev

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION || 'ap-southeast-2' }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push production Docker image
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ needs.setup.outputs.ecr-repo-url }}:latest,${{ needs.setup.outputs.ecr-repo-url }}:${{ needs.setup.outputs.image-tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Note: PR builds should NOT push to ECR - this step has been removed
      # PR validation is handled by helixium-web-ci-cd.yml workflow

  deploy-ecs:
    runs-on: ubuntu-latest
    name: 🚀 Deploy to ECS
    needs: [setup, build-images]
    environment: dev

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION || 'ap-southeast-2' }}

      - name: Check if task definition exists
        id: check-task-def
        run: |
          if aws ecs describe-task-definition --task-definition ${{ env.ECS_TASK_DEFINITION }} --query taskDefinition > task-definition.json 2>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Task definition found"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Task definition not found - infrastructure may not be deployed"
            echo "Please run the infrastructure deployment workflow first"
            exit 1
          fi

      - name: Update task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.json
          container-name: helixium-web
          image: ${{ needs.setup.outputs.ecr-repo-url }}:${{ needs.setup.outputs.image-tag }}

      - name: Deploy to Amazon ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: false

  verify-deployment:
    runs-on: ubuntu-latest
    name: 🔍 Verify Deployment
    needs: [setup, deploy-ecs]
    environment: dev
    outputs:
      public-ip: ${{ steps.get-public-ip.outputs.public-ip }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION || 'ap-southeast-2' }}

      - name: Get deployment URL
        id: get-public-ip
        run: |
          echo "🔍 Getting deployment URL..."

          # Wait a moment for the deployment to start
          echo "⏳ Waiting for deployment to start..."
          sleep 30

          # Function to get public IP with retry logic
          get_public_ip() {
            local max_attempts=10  # Reduced to 10 attempts over ~2 minutes
            local attempt=1
            local base_delay=10
            local max_delay=30
            
            echo "🔄 Starting retry loop to get public IP (max $max_attempts attempts, ~2 minutes total)..."
            
            while [ $attempt -le $max_attempts ]; do
              echo "📋 Attempt $attempt/$max_attempts..."
              
              # Get the task ARN
              TASK_ARN=$(aws ecs list-tasks \
                --cluster ${{ env.ECS_CLUSTER }} \
                --service-name ${{ env.ECS_SERVICE }} \
                --query 'taskArns[0]' \
                --output text 2>/dev/null || echo "")

              if [ "$TASK_ARN" != "None" ] && [ -n "$TASK_ARN" ]; then
                echo "✅ Task found: $TASK_ARN"
                
                # Get detailed task info for debugging
                echo "🔍 Getting detailed task information..."
                aws ecs describe-tasks \
                  --cluster ${{ env.ECS_CLUSTER }} \
                  --tasks $TASK_ARN \
                  --query 'tasks[0].{lastStatus:lastStatus,desiredStatus:desiredStatus,healthStatus:healthStatus,attachments:attachments}' \
                  --output table
                
                # Check if task is running
                TASK_STATUS=$(aws ecs describe-tasks \
                  --cluster ${{ env.ECS_CLUSTER }} \
                  --tasks $TASK_ARN \
                  --query 'tasks[0].lastStatus' \
                  --output text 2>/dev/null || echo "")
                
                if [ "$TASK_STATUS" = "RUNNING" ]; then
                  echo "✅ Task is RUNNING, checking for public IP..."
                  
                  # Get the public IP - using the correct query for ECS tasks
                  PUBLIC_IP=$(aws ecs describe-tasks \
                    --cluster ${{ env.ECS_CLUSTER }} \
                    --tasks $TASK_ARN \
                    --query 'tasks[0].attachments[0].details[?name==`publicIp`].value' \
                    --output text 2>/dev/null || echo "")
                  
                  # If the above doesn't work, try alternative approach
                  if [ -z "$PUBLIC_IP" ] || [ "$PUBLIC_IP" = "None" ]; then
                    echo "🔍 Trying alternative method to get public IP..."
                    # Get the ENI ID first
                    ENI_ID=$(aws ecs describe-tasks \
                      --cluster ${{ env.ECS_CLUSTER }} \
                      --tasks $TASK_ARN \
                      --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
                      --output text 2>/dev/null || echo "")
                    
                    if [ -n "$ENI_ID" ] && [ "$ENI_ID" != "None" ]; then
                      echo "🔍 Found ENI: $ENI_ID, getting public IP..."
                      PUBLIC_IP=$(aws ec2 describe-network-interfaces \
                        --network-interface-ids $ENI_ID \
                        --query 'NetworkInterfaces[0].Association.PublicIp' \
                        --output text 2>/dev/null || echo "")
                    fi
                  fi

                  if [ -n "$PUBLIC_IP" ] && [ "$PUBLIC_IP" != "None" ]; then
                    echo "🎉 Public IP found: $PUBLIC_IP"
                    echo "🌐 Application deployed successfully!"
                    echo "🔗 Access your application at: http://$PUBLIC_IP"
                    echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
                    echo "public-ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
                    return 0
                  else
                    echo "⏳ Public IP not available yet (attempt $attempt/$max_attempts)"
                    echo "🔍 Task is running but public IP not yet assigned"
                  fi
                else
                  echo "⏳ Task status: $TASK_STATUS (waiting for RUNNING state)"
                fi
              else
                echo "⏳ No tasks found yet (attempt $attempt/$max_attempts)"
              fi
              
              # Calculate delay with jitter (exponential backoff with random component)
              if [ $attempt -lt $max_attempts ]; then
                # Exponential backoff: base_delay * 2^(attempt-1)
                local exp_delay=$((base_delay * (2 ** (attempt - 1))))
                # Cap at max_delay
                local delay=$((exp_delay < max_delay ? exp_delay : max_delay))
                # Add jitter: random value between 0 and delay/2
                local jitter=$((RANDOM % (delay / 2 + 1)))
                local total_delay=$((delay + jitter))
                
                echo "⏳ Waiting ${total_delay}s before next attempt (base: ${delay}s + jitter: ${jitter}s)..."
                sleep $total_delay
              fi
              
              attempt=$((attempt + 1))
            done
            
            echo "⚠️  Could not retrieve public IP after $max_attempts attempts"
            echo "💡 This is normal - the task may still be starting up or the public IP may not be available yet"
            echo "🔍 Check the ECS console for task status and public IP"
            echo "🔗 You can also check the ECS console directly:"
            echo "   https://console.aws.amazon.com/ecs/home?region=${{ vars.AWS_REGION || 'ap-southeast-2' }}#/clusters/${{ env.ECS_CLUSTER }}/services/${{ env.ECS_SERVICE }}/tasks"
            echo "🌐 Or check the Application Load Balancer if you're using one"
            return 1
          }

          # Call the function
          get_public_ip

  summary:
    runs-on: ubuntu-latest
    name: 📋 Deployment Summary
    needs: [setup, build-images, deploy-ecs, verify-deployment]
    environment: dev
    if: always()

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Application Deployment Summary
        id: summary
        run: |
          echo "📋 Deployment Summary"
          echo "=================="
          echo ""

          # Check if setup job completed successfully
          if [ "${{ needs.setup.result }}" = "success" ]; then
            echo "✅ Setup job completed successfully"
            echo ""
            echo "🐳 Built and Pushed Images:"
            if [ "${{ github.ref }}" = "refs/heads/main" ] || [ "${{ github.ref }}" = "refs/heads/master" ]; then
              # Safely check if outputs exist before using them
              if [ -n "${{ needs.setup.outputs.ecr-repo-url }}" ]; then
                echo "  • Production: ${{ needs.setup.outputs.ecr-repo-url }}:latest"
                echo "  • Production: ${{ needs.setup.outputs.ecr-repo-url }}:${{ needs.setup.outputs.image-tag }}"
              else
                echo "  • Production: ECR repository URL not available"
              fi
            else
              echo "  • No images pushed (this workflow only runs on main/master branches)"
            fi
          else
            echo "❌ Setup job failed or was skipped"
            echo "🐳 No images were built or pushed"
          fi

          echo ""
          echo "🚀 ECS Deployment:"
          if [ "${{ needs.deploy-ecs.result }}" = "success" ]; then
            echo "  ✅ Deployment job completed successfully"
            echo "  • Cluster: ${{ env.ECS_CLUSTER }}"
            echo "  • Service: ${{ env.ECS_SERVICE }}"
            if [ -n "${{ needs.setup.outputs.ecr-repo-url }}" ] && [ -n "${{ needs.setup.outputs.image-tag }}" ]; then
              echo "  • Image: ${{ needs.setup.outputs.ecr-repo-url }}:${{ needs.setup.outputs.image-tag }}"
            else
              echo "  • Image: Image information not available"
            fi
          else
            echo "  ❌ Deployment job failed or was skipped"
          fi

          echo ""
          echo "🔍 Verification:"
          if [ "${{ needs.verify-deployment.result }}" = "success" ]; then
            echo "  ✅ Verification job completed successfully"
            # Check if PUBLIC_IP was set in the verify-deployment job
            if [ -n "${{ needs.verify-deployment.outputs.public-ip }}" ]; then
              echo "  🌐 Application URL: http://${{ needs.verify-deployment.outputs.public-ip }}"
            else
              echo "  🌐 Application URL: Not available (check ECS console)"
            fi
          else
            echo "  ❌ Verification job failed or was skipped"
            echo "  🌐 Application URL: Not available (check ECS console)"
          fi

          echo ""
          echo "📝 Next steps:"
          if [ "${{ needs.deploy-ecs.result }}" = "success" ]; then
            echo "  1. Test your application at the provided URL"
            echo "  2. Monitor logs in CloudWatch"
            echo "  3. Scale your service as needed"
            echo "deployment-status=success" >> $GITHUB_OUTPUT
          else
            echo "  1. Check the deployment job logs for errors"
            echo "  2. Verify infrastructure is properly deployed"
            echo "  3. Retry the deployment if needed"
            echo "deployment-status=failure" >> $GITHUB_OUTPUT
          fi

          # Set deployment URL for Slack notification
          if [ "${{ needs.verify-deployment.result }}" = "success" ]; then
            echo "deployment-url=https://helixium.nicholasfane.com" >> $GITHUB_OUTPUT
          else
            echo "deployment-url=Not available" >> $GITHUB_OUTPUT
          fi

      - name: Notify Slack
        if: always()
        uses: slackapi/slack-github-action@v1.24.0
        with:
          channel-id: ${{ secrets.SLACK_CHANNEL_ID }}
          payload: |
            {
              "text": "<!here> 🚀 Helixium Deployment ${{ steps.summary.outputs.deployment-status == 'success' && '✅ Successful' || '❌ Failed' }}",
              "link_names": true,
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "<!here> 🚀 Helixium Deployment ${{ steps.summary.outputs.deployment-status == 'success' && '✅ Successful' || '❌ Failed' }}"
                  }
                },
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "🚀 Helixium Deployment ${{ steps.summary.outputs.deployment-status == 'success' && '✅ Successful' || '❌ Failed' }}"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Repository:*\n${{ github.repository }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Branch:*\n${{ github.ref_name }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Commit:*\n${{ github.sha }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Triggered by:*\n${{ github.actor }}"
                    }
                  ]
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Setup:*\n${{ needs.setup.result == 'success' && '✅ Success' || '❌ Failed' }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Build:*\n${{ needs.build-images.result == 'success' && '✅ Success' || '❌ Failed' }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Deploy:*\n${{ needs.deploy-ecs.result == 'success' && '✅ Success' || '❌ Failed' }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Verify:*\n${{ needs.verify-deployment.result == 'success' && '✅ Success' || '❌ Failed' }}"
                    }
                  ]
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*🌐 Application URL:*\n${{ steps.summary.outputs.deployment-url }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*📋 Summary:*\n${{ steps.summary.outputs.deployment-status == 'success' && '• Images built and pushed to ECR\n• Application deployed to ECS\n• Ready for testing' || '• Deployment encountered issues\n• Check GitHub Actions logs for details' }}"
                  }
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Workflow"
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
