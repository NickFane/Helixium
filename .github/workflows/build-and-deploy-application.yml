name: Build and Deploy Application

on:
  push:
    branches: [main, master]
    paths:
      - "helixium-web/**"
      - "Dockerfile*"
      - "docker-compose.yml"
      - "nginx.conf"
      - ".dockerignore"
      - ".github/workflows/build-and-deploy-application.yml"
  workflow_run:
    workflows: ["Build and Deploy Terraform Infrastructure"]
    types:
      - completed
    branches: [main, master]
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Docker image tag to deploy (default: latest)"
        required: false
        default: "latest"

env:
  AWS_REGION: ${{ vars.AWS_REGION || 'ap-southeast-2' }}
  ECS_CLUSTER: "helixium-cluster"
  ECS_SERVICE: "helixium-service"
  ECS_TASK_DEFINITION: "helixium"

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    name: Build and Deploy Application
    environment: dev
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'push' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Debug Workflow Trigger
        run: |
          echo "üîç DEBUGGING WORKFLOW TRIGGER:"
          echo "Event name: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Branch: ${{ github.ref_name }}"
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "Triggered by workflow: ${{ github.event.workflow_run.name }}"
            echo "Workflow conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "Workflow run ID: ${{ github.event.workflow_run.id }}"
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION || 'ap-southeast-2' }}

      - name: Check if infrastructure is deployed
        run: |
          if aws ecs describe-clusters --clusters ${{ env.ECS_CLUSTER }} --query 'clusters[0].status' --output text 2>/dev/null | grep -q ACTIVE; then
            echo "ECS cluster is active"
          else
            echo "ECS cluster not found or not active"
            echo "Please run the infrastructure deployment workflow first"
            exit 1
          fi

      - name: Get ECR Repository URLs
        run: |
          echo "üîç Getting ECR repository URLs..."

          # Try to get ECR repository URLs from AWS directly
          echo "üìã Getting ECR repository URLs from AWS..."

          # Get production repository URL
          ECR_REPO_URL=$(aws ecr describe-repositories \
            --repository-names helixium-web \
            --query 'repositories[0].repositoryUri' \
            --output text 2>/dev/null || echo "")

          # Get development repository URL  
          ECR_DEV_REPO_URL=$(aws ecr describe-repositories \
            --repository-names helixium-web-dev \
            --query 'repositories[0].repositoryUri' \
            --output text 2>/dev/null || echo "")

          if [ -n "$ECR_REPO_URL" ] && [ -n "$ECR_DEV_REPO_URL" ]; then
            echo "ECR_REPOSITORY_URL=$ECR_REPO_URL" >> $GITHUB_ENV
            echo "ECR_DEV_REPOSITORY_URL=$ECR_DEV_REPO_URL" >> $GITHUB_ENV
            echo "‚úÖ ECR repository URLs retrieved from AWS"
            echo "  Production: $ECR_REPO_URL"
            echo "  Development: $ECR_DEV_REPO_URL"
          else
            echo "‚ùå Could not get ECR repository URLs from AWS"
            echo "üí° This might mean:"
            echo "   - Infrastructure hasn't been deployed yet"
            echo "   - ECR repositories don't exist"
            echo "   - AWS credentials don't have ECR permissions"
            echo ""
            echo "üîß Please run the infrastructure deployment workflow first"
            exit 1
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set image tag
        id: set-tag
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.image_tag }}" ]; then
            echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

      # Build and push production Docker image (for main/master)
      - name: Build and push production Docker image
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ env.ECR_REPOSITORY_URL }}:latest,${{ env.ECR_REPOSITORY_URL }}:${{ steps.set-tag.outputs.tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Build and push development Docker image (for main/master)
      - name: Build and push development Docker image
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.dev
          push: true
          tags: ${{ env.ECR_DEV_REPOSITORY_URL }}:${{ steps.set-tag.outputs.tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Build and push development Docker image (for pull requests)
      - name: Build and push development Docker image (PR)
        if: github.event_name == 'pull_request'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.dev
          push: true
          tags: ${{ env.ECR_DEV_REPOSITORY_URL }}:pr-${{ github.event.number }}-${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Check if task definition exists
        id: check-task-def
        run: |
          if aws ecs describe-task-definition --task-definition ${{ env.ECS_TASK_DEFINITION }} --query taskDefinition > task-definition.json 2>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Task definition found"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Task definition not found - infrastructure may not be deployed"
            echo "Please run the infrastructure deployment workflow first"
            exit 1
          fi

      - name: Update task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.json
          container-name: helixium-web
          image: ${{ env.ECR_REPOSITORY_URL }}:${{ steps.set-tag.outputs.tag }}

      - name: Deploy to Amazon ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: false

      - name: Get deployment URL
        run: |
          echo "üîç Getting deployment URL..."

          # Wait a moment for the deployment to start
          echo "‚è≥ Waiting for deployment to start..."
          sleep 30

          # Get the task ARN
          TASK_ARN=$(aws ecs list-tasks \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service-name ${{ env.ECS_SERVICE }} \
            --query 'taskArns[0]' \
            --output text)

          if [ "$TASK_ARN" != "None" ] && [ -n "$TASK_ARN" ]; then
            # Get the public IP
            PUBLIC_IP=$(aws ecs describe-tasks \
              --cluster ${{ env.ECS_CLUSTER }} \
              --tasks $TASK_ARN \
              --query 'tasks[0].attachments[0].details[?name==`publicIp`].value' \
              --output text)

            if [ -n "$PUBLIC_IP" ] && [ "$PUBLIC_IP" != "None" ]; then
              echo "üåê Application deployed successfully!"
              echo "üîó Access your application at: http://$PUBLIC_IP"
              echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
            else
              echo "‚ö†Ô∏è  Could not retrieve public IP. The task may still be starting up."
              echo "üí° Check the ECS console for task status and public IP"
            fi
          else
            echo "‚ö†Ô∏è  No tasks found. The service may still be starting up."
            echo "üí° Check the ECS console for service status"
          fi

      - name: Application Deployment Summary
        run: |
          echo "üéâ Application build and deployment completed successfully!"
          echo ""
          echo "üê≥ Built and Pushed Images:"
          if [ "${{ github.ref }}" = "refs/heads/main" ] || [ "${{ github.ref }}" = "refs/heads/master" ]; then
            echo "  ‚Ä¢ Production: ${{ env.ECR_REPOSITORY_URL }}:latest"
            echo "  ‚Ä¢ Production: ${{ env.ECR_REPOSITORY_URL }}:${{ steps.set-tag.outputs.tag }}"
            echo "  ‚Ä¢ Development: ${{ env.ECR_DEV_REPOSITORY_URL }}:${{ steps.set-tag.outputs.tag }}"
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "  ‚Ä¢ Development: ${{ env.ECR_DEV_REPOSITORY_URL }}:pr-${{ github.event.number }}-${{ github.sha }}"
          fi
          echo ""
          echo "üöÄ Deployed to ECS:"
          echo "  ‚Ä¢ Cluster: ${{ env.ECS_CLUSTER }}"
          echo "  ‚Ä¢ Service: ${{ env.ECS_SERVICE }}"
          echo "  ‚Ä¢ Image: ${{ env.ECR_REPOSITORY_URL }}:${{ steps.set-tag.outputs.tag }}"
          echo ""
          if [ -n "${{ env.PUBLIC_IP }}" ]; then
            echo "üåê Application URL: http://${{ env.PUBLIC_IP }}"
          fi
          echo ""
          echo "üìù Next steps:"
          echo "  1. Test your application at the provided URL"
          echo "  2. Monitor logs in CloudWatch"
          echo "  3. Scale your service as needed"
